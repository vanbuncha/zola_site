<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>vanbuncha</title>
    <subtitle>Personal site for documenting projects and blogging stuff.</subtitle>
    <link href="https://vanguyen.info/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://vanguyen.info"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-03-12T00:00:00+00:00</updated>
    <id>https://vanguyen.info/atom.xml</id>
    <entry xml:lang="en">
        <title>Spotify API</title>
        <published>2023-03-12T00:00:00+00:00</published>
        <updated>2023-03-12T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://vanguyen.info/projects/spotify-api-project/" type="text/html"/>
        <id>https://vanguyen.info/projects/spotify-api-project/</id>
        <content type="html">&lt;h1 id=&quot;building-a-simple-spotify-player-with-javascript&quot;&gt;Building a Simple Spotify Player with JavaScript&lt;&#x2F;h1&gt;
&lt;p&gt;As a music lover and a web developer, I have always been interested in exploring the Spotify Web API and building a simple web application that can control my music playback on the platform. So, I decided to create a simple Spotify player using JavaScript that allows me to log in to my account, fetch my playlists and songs, and control my music playback from a single interface.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;&#x2F;h2&gt;
&lt;p&gt;To build this project, I used the following technologies:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript for the frontend code&lt;&#x2F;li&gt;
&lt;li&gt;HTML and CSS for the UI&lt;&#x2F;li&gt;
&lt;li&gt;Spotify Web API for accessing the Spotify platform
To start building the application, I first had to create a Spotify Web API client ID and secret key, which I obtained by registering a new app on the Spotify Developer Dashboard. I then used the client ID and secret key in my JavaScript code to authenticate the user and fetch their data from the Spotify platform.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;building-the-application&quot;&gt;Building the Application&lt;&#x2F;h2&gt;
&lt;p&gt;The first step in building the application was to create a UI that allowed me to log in to my Spotify account and fetch my data from the platform. I used HTML and CSS to create a login form that allowed users to enter their Spotify credentials and authenticate the application.&lt;&#x2F;p&gt;
&lt;p&gt;Once the user was authenticated, I used the Spotify Web API to fetch their playlists and songs from the platform. I then displayed this data on the UI in a user-friendly manner, allowing the user to easily navigate and control their music playback.&lt;&#x2F;p&gt;
&lt;p&gt;To control the music playback, I used the Spotify Web API to play&#x2F;pause, skip to the next or previous track, and adjust the volume of the playback using JavaScript code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-interesting-quirk&quot;&gt;An Interesting Quirk&lt;&#x2F;h2&gt;
&lt;p&gt;As I was building this Spotify player, I noticed an interesting quirk that I had never encountered before. Whenever I made changes to my script.js or style.css files and tried to refresh my browser, the changes would not take effect. I would refresh the page multiple times and even clear my cache, but the old files would remain the same.&lt;&#x2F;p&gt;
&lt;p&gt;After some investigation, I discovered that this issue was caused by browser caching. Browsers often cache static files like JavaScript and CSS files to improve page loading speed. However, this can also lead to issues when developing, as changes to these files may not be immediately reflected in the browser.&lt;&#x2F;p&gt;
&lt;p&gt;To solve this issue, I found that renaming the file and updating the reference in my HTML file solved the problem. For example, if I made changes to script.js, I would rename the file to something like script-v2.js and update the reference in my HTML file accordingly. This forces the browser to recognize the updated file and load the new version.&lt;&#x2F;p&gt;
&lt;p&gt;While this quirk may have caused some frustration (2hours of pure frustration) during development, it was an interesting discovery that taught me more about how browsers handle static files and caching. It also serves as a reminder to always double-check if changes are being reflected in the browser, and to clear the cache if necessary.&lt;&#x2F;p&gt;
&lt;p&gt;Deployment
After completing the development of my Spotify player using JavaScript, HTML, and CSS, I wanted to deploy it on my website and make it accessible to the public. To do this, I followed these simple steps:&lt;&#x2F;p&gt;
&lt;p&gt;Connect to my web hosting provider and access the file manager for my website.
Delete any existing files in the website directory where I wanted to deploy my application.
SSH into your server and navigate to the directory where you want to deploy your application. Then, run the following commands:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo rm -rf html&#x2F;spotify_api_project
&lt;&#x2F;span&gt;&lt;span&gt;sudo git clone https:&#x2F;&#x2F;github.com&#x2F;vanbuncha&#x2F;spotify_api_project
&lt;&#x2F;span&gt;&lt;span&gt;sudo mv spotify_api_project&#x2F;spotify_api_project html
&lt;&#x2F;span&gt;&lt;span&gt;sudo rm -rf spotify_api_project
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These commands will first delete any existing files in the html&#x2F;spotify_api_project directory, clone the GitHub repository containing your application, move the cloned repository to the html directory, and then delete the original cloned repository.&lt;&#x2F;p&gt;
&lt;p&gt;Ensure that the file permissions for your application files are set correctly, so that they are readable by the web server.
After completing these steps, your Spotify player will be successfully deployed on your website and will be accessible to the public. Anyone who visits the URL for your website can control their Spotify music playback using the web application, making it a convenient and fun addition to your website.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Building this simple Spotify player was a fun and rewarding experience. I learned a lot about the Spotify Web API and how to use it to create a seamless music playback experience for the user. If you&#x27;re interested in building your own music player using JavaScript, I highly recommend exploring the Spotify Web API and experimenting with the various features and functionalities it offers. With a little bit of creativity and some JavaScript skills, you can create a custom music player that&#x27;s tailored to your personal preferences and music taste.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;vanguyen.info&#x2F;spotify_api_project&#x2F;&quot;&gt;Link to the Spotify API project&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;to-do-list&quot;&gt;To-Do List&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
Add logout option&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
Fetch info about user&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
Fix Currently playing box&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
Passively check currently playing song&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
    </entry>
    <entry xml:lang="en">
        <title>File service - Nextcloud</title>
        <published>2023-03-09T00:00:00+00:00</published>
        <updated>2023-03-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://vanguyen.info/projects/nextcloud/" type="text/html"/>
        <id>https://vanguyen.info/projects/nextcloud/</id>
        <content type="html">&lt;p&gt;Self hosted file service&lt;&#x2F;p&gt;
&lt;h1 id=&quot;part-one-subdomain&quot;&gt;Part one -- subdomain&lt;&#x2F;h1&gt;
&lt;p&gt;As a web developer, I am always looking for new ways to improve my setup and make my web development projects more accessible to others. Recently, I decided to try and add a subdomain to my Raspberry Pi Apache server using Cloudflare Tunnel, but unfortunately, I did not have success. Here is my experience.&lt;&#x2F;p&gt;
&lt;p&gt;First, I set up my Raspberry Pi with Apache, following various tutorials on the web. I also configured my router to forward incoming requests to the Raspberry Pi’s IP address, so that the web server could be accessed from the internet. Next, I signed up for a Cloudflare account and set up a tunnel to my Raspberry Pi using the Cloudflare CLI. This was relatively easy, and I was able to connect to my web server using the tunnel URL provided by Cloudflare.&lt;&#x2F;p&gt;
&lt;p&gt;Now, I wanted to add a subdomain to my setup. I had already registered a domain name with a popular registrar and set up Cloudflare as my DNS provider. I added an A record pointing to my Raspberry Pi’s IP address, and set up a CNAME record pointing to the tunnel URL provided by Cloudflare. I also added a Page Rule to forward all traffic to my subdomain to the tunnel URL. However, when I tried to access my subdomain, I was greeted with a 502 Bad Gateway error.&lt;&#x2F;p&gt;
&lt;p&gt;I spent hours troubleshooting the issue, checking my Apache configuration files, and trying different combinations of DNS records and Page Rules. I also consulted various online forums and documentation, but I could not find a solution. Eventually, I realized that the issue might be with Cloudflare Tunnel itself, and not my setup.&lt;&#x2F;p&gt;
&lt;p&gt;I discovered that Cloudflare Tunnel does not support subdomains out of the box. While it is possible to use subdomains with Cloudflare Tunnel, it requires additional configuration and setup, which is beyond the scope of this blog post. I was disappointed that my initial attempt to add a subdomain to my Raspberry Pi Apache + Cloudflare Tunnel setup did not succeed, but I learned a valuable lesson about the limitations of certain tools and services.&lt;&#x2F;p&gt;
&lt;p&gt;p.s This could be all avoided with better router.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;part-two-installing-nextcloud-and-its-usecases&quot;&gt;Part two -- Installing Nextcloud and its usecases&lt;&#x2F;h1&gt;
&lt;p&gt;Nextcloud is a free and open-source software platform for creating and hosting file hosting and communication services on your own servers. It offers features like file sharing, calendar, contact management, and more.&lt;&#x2F;p&gt;
&lt;p&gt;To install Nextcloud on a Raspberry Pi, I followed these steps:&lt;&#x2F;p&gt;
&lt;p&gt;Preparing the Raspberry Pi: First, I prepared my Raspberry Pi by installing the latest version of Raspberry Pi OS and enabling SSH access.
Installing Apache and PHP: I installed Apache web server and PHP on my Raspberry Pi using the following command in the terminal:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt-get install apache2 php libapache2-mod-php
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Creating a Virtual Host: Next, I created a virtual host for Nextcloud by creating a new configuration file in the Apache sites-available directory using the following command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo nano &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;nextcloud.conf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I added the following lines to the configuration file:&lt;&#x2F;p&gt;
&lt;p&gt;bash&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;VirtualHost *:80&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        ServerAdmin webmaster@localhost
&lt;&#x2F;span&gt;&lt;span&gt;        DocumentRoot &#x2F;var&#x2F;www&#x2F;nextcloud&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;        Servvanguyen.info
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;Directory &#x2F;var&#x2F;www&#x2F;nextcloud&#x2F;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;                Options +FollowSymlinks
&lt;&#x2F;span&gt;&lt;span&gt;                AllowOverride All
&lt;&#x2F;span&gt;&lt;span&gt;                Require all granted
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;IfModule mod_dav.c&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;                        Dav off
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;lt;&#x2F;IfModule&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;                SetEnv HOME &#x2F;var&#x2F;www&#x2F;nextcloud
&lt;&#x2F;span&gt;&lt;span&gt;                SetEnv HTTP_HOME &#x2F;var&#x2F;www&#x2F;nextcloud
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;lt;&#x2F;Directory&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;        ErrorLog ${APACHE_LOG_DIR}&#x2F;error.log
&lt;&#x2F;span&gt;&lt;span&gt;        CustomLog ${APACHE_LOG_DIR}&#x2F;access.log combined
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&#x2F;VirtualHost&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I saved the configuration file and enabled the site using the following command:&lt;&#x2F;p&gt;
&lt;p&gt;sudo a2ensite nextcloud.conf&lt;&#x2F;p&gt;
&lt;p&gt;Downloading and Installing Nextcloud: I downloaded the latest version of Nextcloud from their website and copied the files to the web root directory &#x2F;var&#x2F;www&#x2F;nextcloud&#x2F; on my Raspberry Pi using the following commands:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;wget https:&#x2F;&#x2F;download.nextcloud.com&#x2F;server&#x2F;releases&#x2F;nextcloud-22.3.0.zip
&lt;&#x2F;span&gt;&lt;span&gt;sudo unzip nextcloud-22.3.0.zip -d &#x2F;var&#x2F;www&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;nextcloud&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Setting Up a Database: Next, I set up a MySQL database for Nextcloud using the following commands:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt-get install mariadb-server php-mysql
&lt;&#x2F;span&gt;&lt;span&gt;sudo mysql_secure_installation
&lt;&#x2F;span&gt;&lt;span&gt;sudo mysql -u root -p
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I created a new database and user for Nextcloud, and granted the user permissions to the database:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;CREATE DATABASE nextcloud;
&lt;&#x2F;span&gt;&lt;span&gt;CREATE USER &amp;#39;nextclouduser&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;password&amp;#39;;
&lt;&#x2F;span&gt;&lt;span&gt;GRANT ALL PRIVILEGES ON nextcloud.* TO &amp;#39;nextclouduser&amp;#39;@&amp;#39;localhost&amp;#39;;
&lt;&#x2F;span&gt;&lt;span&gt;FLUSH PRIVILEGES;
&lt;&#x2F;span&gt;&lt;span&gt;exit;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Completing the Installation: Finally, I accessed the Nextcloud installation wizard by visiting vanguyen.info&#x2F;nextcloud in my web browser. I entered the database details and created an administrator account, and then completed the installation.
That&#x27;s it! Now, I can access my Nextcloud instance by visiting vanguyen.info&#x2F;nextcloud on my Raspberry Pi.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;vanguyen.info&#x2F;nextcloud&#x2F;index.php&#x2F;login&quot;&gt;Link to Nextcloud&lt;&#x2F;a&gt; &lt;&#x2F;p&gt;
&lt;h1 id=&quot;to-do-list&quot;&gt;To-Do List&lt;&#x2F;h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
Use external storage&lt;&#x2F;li&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&#x2F;&gt;
set up SMTP service&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
    </entry>
    <entry xml:lang="en">
        <title>Public website</title>
        <published>2023-02-28T00:00:00+00:00</published>
        <updated>2023-02-28T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://vanguyen.info/projects/zola-project/" type="text/html"/>
        <id>https://vanguyen.info/projects/zola-project/</id>
        <content type="html">&lt;p&gt;Public website with self-hosting&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;&lt;h1 id=&quot;deploying-my-website-onto-a-raspberry-pi-with-apache-server-using-cloudflare-and-ssg-zola&quot;&gt;Deploying My Website onto a Raspberry Pi with Apache Server using Cloudflare and SSG Zola&lt;&#x2F;h1&gt;
&lt;p&gt;Hello, fellow tech enthusiasts! In this blog post, I&#x27;m excited to share my experience of deploying my website onto a Raspberry Pi with Apache server using Cloudflare and SSG Zola.&lt;&#x2F;p&gt;
&lt;p&gt;Before we get started, I should note that I&#x27;m not a web development expert. However, I love tinkering with technology and learning new things, and that&#x27;s how I ended up taking on this challenge.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;installing-apache-server&quot;&gt;Installing Apache Server&lt;&#x2F;h2&gt;
&lt;p&gt;First things first, I made sure that my Raspberry Pi was up-to-date with the latest software updates. Next, I installed Apache server on the Pi by running the following command in the terminal:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo apt-get install apache2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once Apache was up and running, I tested it out by typing the IP address of the Raspberry Pi into a web browser. Lo and behold, the Apache default page was displayed!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;configuring-my-router-and-dns&quot;&gt;Configuring My Router and DNS&lt;&#x2F;h2&gt;
&lt;p&gt;When I set out to host my website on a Raspberry Pi, I ran into a roadblock when I realized that my router was unable to port forward to the Pi due to my ISP&#x27;s carrier-grade NAT. I knew that I needed a solution that would allow me to host my website securely and reliably without relying on port forwarding. After some research, I came across Cloudflare Tunnel, which seemed like the perfect solution.&lt;&#x2F;p&gt;
&lt;p&gt;To get started, I created an account on Cloudflare and downloaded the Cloudflare Tunnel CLI on my Raspberry Pi. I then configured the tunnel using the command line interface, specifying my local host and port number, and giving it a name.&lt;&#x2F;p&gt;
&lt;p&gt;Once the tunnel was set up, I tested it out by visiting the hostname that Cloudflare had assigned to my tunnel. To my delight, my website was now accessible from the internet through Cloudflare&#x27;s servers. Even better, the tunnel was secured with TLS encryption, providing an added layer of security to my website.&lt;&#x2F;p&gt;
&lt;p&gt;Using Cloudflare Tunnel allowed me to bypass my router&#x27;s inability to port forward to my Raspberry Pi, and host my website reliably and securely. The setup was relatively easy and straightforward, and I was able to get my website up and running in no time. If you&#x27;re facing a similar port forwarding issue, I highly recommend giving Cloudflare Tunnel a &lt;a href=&quot;https:&#x2F;&#x2F;pimylifeup.com&#x2F;raspberry-pi-cloudflare-tunnel&#x2F;&quot;&gt;try&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;installing-ssg-zola&quot;&gt;Installing SSG Zola&lt;&#x2F;h2&gt;
&lt;p&gt;With Apache and DNS set up, I was ready to install SSG Zola, a static site generator. I used SSG Zola to create a simple website in Markdown language. Once the site was ready, I used the zola build command to generate the static HTML files for my website.&lt;&#x2F;p&gt;
&lt;p&gt;SG Zola is a static site generator (SSG) that allows you to create fast, secure, and modern websites with ease. Unlike traditional content management systems (CMS) that require a database and server-side processing, static site generators like Zola generate static HTML, CSS, and JavaScript files that can be served directly by a web server, making them faster, more secure, and easier to host.&lt;&#x2F;p&gt;
&lt;p&gt;Zola is written in Rust, a fast and safe systems programming language, and is designed to be easy to use and highly customizable. It comes with a powerful set of features, including a built-in web server for local development, support for templates, partials, and custom shortcodes, automatic image resizing and optimization, and support for multiple content formats including Markdown, HTML, and JSON.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;uploading-my-site-to-the-raspberry-pi&quot;&gt;Uploading My Site to the Raspberry Pi&lt;&#x2F;h2&gt;
&lt;p&gt;To deploy my website from my GitHub repository, I use a simple bash script called gitreplace.sh. The script performs the following commands:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo git clone https:&#x2F;&#x2F;github.com&#x2F;vanbuncha&#x2F;zola_site
&lt;&#x2F;span&gt;&lt;span&gt;sudo mv zola_site&#x2F;zola_site&#x2F;public .
&lt;&#x2F;span&gt;&lt;span&gt;sudo rm -rf html
&lt;&#x2F;span&gt;&lt;span&gt;sudo mv public html
&lt;&#x2F;span&gt;&lt;span&gt;sudo rm -rf zola_site
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First, the script clones my GitHub repository onto my Raspberry Pi using sudo git clone https:&#x2F;&#x2F;github.com&#x2F;vanbuncha&#x2F;zola_site. Next, it moves the public folder from the cloned repository to the current directory using sudo mv zola_site&#x2F;zola_site&#x2F;public .. It then removes any existing html directory using sudo rm -rf html to avoid conflicts, and renames the public directory to html, which is the default directory for Apache to serve web pages from, using sudo mv public html. Lastly, it cleans up the cloned repository using sudo rm -rf zola_site to keep things tidy.&lt;&#x2F;p&gt;
&lt;p&gt;To ensure that my website is always up-to-date, I&#x27;ve set up a &lt;b&gt;cron&lt;&#x2F;b&gt; job to run the gitreplace.sh script every 69 minutes. This is done by adding the following line to my crontab file using crontab -e:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;*&#x2F;10 * * * * &#x2F;path&#x2F;to&#x2F;gitreplace.sh &amp;gt; &#x2F;path&#x2F;to&#x2F;gitreplace.log 2&amp;gt;&amp;amp;1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This tells cron to run the deploy.sh script every 10 minutes, and to log any output or errors to &#x2F;path&#x2F;to&#x2F;deploy.log. With this setup, I can make changes to my website on GitHub and have them reflected on my server within minutes.&lt;&#x2F;p&gt;
&lt;p&gt;** This script also updates &lt;a href=&quot;https:&#x2F;&#x2F;vanguyen.info&#x2F;spotify_api_project&#x2F;&quot;&gt;Spotify API project&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;remote-control-and-deployment&quot;&gt;Remote control and deployment&lt;&#x2F;h2&gt;
&lt;p&gt;Accessing my Raspberry Pi on my local network was easy using SSH. I simply opened up the terminal on my computer and entered the command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#80cbc4;&quot;&gt;&lt;code&gt;&lt;span&gt;ssh pi@192.168.1.XXX
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;where XXX is the IP address of my Raspberry Pi on the local network. This allowed me to connect to the Pi and access its command line interface from my computer. From there, I could run commands, manage files, and do pretty much anything else I needed to do on the Pi.&lt;&#x2F;p&gt;
&lt;p&gt;However, accessing my Raspberry Pi from a public network was a different story. Because my ISP used carrier-grade NAT, I couldn&#x27;t access my Pi directly from the internet. This is where PiTunnel came in handy.&lt;&#x2F;p&gt;
&lt;p&gt;PiTunnel is a service that allows you to create a secure tunnel to your Raspberry Pi from the internet, bypassing any NAT or firewall restrictions. To set it up, I created an account on the PiTunnel website and downloaded the PiTunnel client on my Raspberry Pi. I then configured the tunnel and started the client.&lt;&#x2F;p&gt;
&lt;p&gt;With the tunnel running, I could access my Raspberry Pi from the internet by visiting the URL provided by PiTunnel. I could even use SSH to connect to the Pi and access its command line interface from anywhere in the world.&lt;&#x2F;p&gt;
&lt;p&gt;Using SSH to access my Raspberry Pi on my local network and PiTunnel to access it from the internet made managing my Pi a breeze. I could access it from anywhere, run commands, manage files, and do pretty much anything else I needed to do without any hassle.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;Deploying my website onto a Raspberry Pi with Apache server using Cloudflare and SSG Zola was a fun and educational experience. It allowed me to learn more about web development, Linux administration, and networking. I hope that sharing my experience will inspire others to tinker with technology and explore new horizons.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Webserver: Raspberry Pi 3 Model B, Raspbian, Apache&#x2F;2.4.54 (Debian)&lt;&#x2F;li&gt;
&lt;li&gt;Port forwarding: Cloudfare Tunnel&lt;&#x2F;li&gt;
&lt;li&gt;Content: SSG Zola &lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;*text ai generated&lt;&#x2F;p&gt;
</content>
    </entry>
    <entry xml:lang="en">
        <title>Why vanbuncha</title>
        <published>2023-02-20T00:00:00+00:00</published>
        <updated>2023-02-20T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://vanguyen.info/blog/first-blog/" type="text/html"/>
        <id>https://vanguyen.info/blog/first-blog/</id>
        <content type="html">&lt;h1 id=&quot;origin&quot;&gt;Origin?&lt;a class=&quot;zola-anchor&quot; href=&quot;#origin&quot; aria-label=&quot;Anchor link for: origin&quot;&gt;🔗&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Have you ever wondered how the nickname &amp;quot;vanbuncha&amp;quot; came to be? Well, let me tell you the story.&lt;&#x2F;p&gt;
&lt;p&gt;Picture this: it was 2012, and I was a young and enthusiastic fan of football. I was the only Asian on a team full of cheerful kids and adults, and as a result, they gave me the nickname &amp;quot;Fun Din Dung&amp;quot;. While it was popular amongst my peers, it wasn&#x27;t an original nickname until one day, my coach exclaimed &amp;quot;Van bún cùng chả&amp;quot; (in a Czech accent), referring to a Vietnamese dish that was becoming popular in the Czech Republic. And just like that, a new nickname was born.&lt;&#x2F;p&gt;
&lt;p&gt;On September 6th, 2012, I immortalized this new nickname by creating the email vanbuncha.nguyen, which I still use to this day.&lt;&#x2F;p&gt;
&lt;p&gt;Over the years, other nicknames have come and gone, such as &amp;quot;Wafik&amp;quot; (which means successful in Arabic) and &amp;quot;vanba&amp;quot; (derived from Ho Chi Minh&#x27;s alias during his stay on a French merchant steamer). But none of them have stuck like &amp;quot;vanbuncha&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;Despite its joke origin and possible derogatory connotation to my ethnic origin, I still use the nickname to this day. After all, it&#x27;s all in good fun!&lt;&#x2F;p&gt;
</content>
    </entry>
</feed>
